use glam::{Vec3, Vec4};

use crate::AsValue;

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
/// Color type represented as RGBA
pub struct Color([u8; 4]);

impl AsValue<[f32; 4]> for Color {
    fn as_value(&self) -> [f32; 4] {
        [
            f32::from(self.0[0]) / 255.0,
            f32::from(self.0[1]) / 255.0,
            f32::from(self.0[2]) / 255.0,
            f32::from(self.0[3]) / 255.0,
        ]
    }
}

impl AsValue<[f32; 3]> for Color {
    fn as_value(&self) -> [f32; 3] {
        [
            f32::from(self.0[0]) / 255.0,
            f32::from(self.0[1]) / 255.0,
            f32::from(self.0[2]) / 255.0,
        ]
    }
}

impl AsValue<Vec4> for Color {
    fn as_value(&self) -> Vec4 {
        Vec4::from_array(self.as_value())
    }
}

impl AsValue<Vec3> for Color {
    fn as_value(&self) -> Vec3 {
        Vec3::from_array(self.as_value())
    }
}

impl From<Vec4> for Color {
    fn from(value: Vec4) -> Self {
        Self([
            (255.0 * value.x) as u8,
            (255.0 * value.y) as u8,
            (255.0 * value.z) as u8,
            (255.0 * value.w) as u8,
        ])
    }
}

impl From<Vec3> for Color {
    fn from(value: Vec3) -> Self {
        Self([
            (255.0 * value.x) as u8,
            (255.0 * value.y) as u8,
            (255.0 * value.z) as u8,
            255,
        ])
    }
}

impl AsValue<[u8; 4]> for Color {
    fn as_value(&self) -> [u8; 4] {
        self.0
    }
}

const fn color_to_linear(color: u8) -> f32 {
    COLOR_TO_LINEAR[color as usize]
}

const COLOR_TO_LINEAR: [f32; 256] = [
    0.000_000_00,
    0.000_303_53,
    0.000_607_05,
    0.000_910_58,
    0.001_214_11,
    0.001_517_63,
    0.001_821_16,
    0.002_124_69,
    0.002_428_22,
    0.002_731_74,
    0.003_035_27,
    0.003_346_54,
    0.003_676_51,
    0.004_024_72,
    0.004_391_44,
    0.004_776_95,
    0.005_181_52,
    0.005_605_39,
    0.006_048_83,
    0.006_512_09,
    0.006_995_41,
    0.007_499_03,
    0.008_023_19,
    0.008_568_13,
    0.009_134_06,
    0.009_721_22,
    0.010_329_82,
    0.010_960_09,
    0.011_612_25,
    0.012_286_49,
    0.012_983_03,
    0.013_702_08,
    0.014_443_84,
    0.015_208_51,
    0.015_996_29,
    0.016_807_38,
    0.017_641_95,
    0.018_500_22,
    0.019_382_36,
    0.020_288_56,
    0.021_219_01,
    0.022_173_88,
    0.023_153_37,
    0.024_157_63,
    0.025_186_86,
    0.026_241_22,
    0.027_320_89,
    0.028_426_04,
    0.029_556_83,
    0.030_713_44,
    0.031_896_03,
    0.033_104_77,
    0.034_339_81,
    0.035_601_31,
    0.036_889_45,
    0.038_204_37,
    0.039_546_24,
    0.040_915_2,
    0.042_311_41,
    0.043_735_03,
    0.045_186_2,
    0.046_665_09,
    0.048_171_82,
    0.049_706_57,
    0.051_269_46,
    0.052_860_65,
    0.054_480_28,
    0.056_128_49,
    0.057_805_43,
    0.059_511_24,
    0.061_246_05,
    0.063_010_02,
    0.064_803_27,
    0.066_625_94,
    0.068_478_17,
    0.070_360_1,
    0.072_271_85,
    0.074_213_57,
    0.076_185_38,
    0.078_187_42,
    0.080_219_82,
    0.082_282_71,
    0.084_376_21,
    0.086_500_46,
    0.088_655_59,
    0.090_841_71,
    0.093_058_96,
    0.095_307_47,
    0.097_587_35,
    0.099_898_73,
    0.102_241_73,
    0.104_616_48,
    0.107_023_1,
    0.109_461_71,
    0.111_932_43,
    0.114_435_37,
    0.116_970_67,
    0.119_538_43,
    0.122_138_77,
    0.124_771_82,
    0.127_437_68,
    0.130_136_48,
    0.132_868_32,
    0.135_633_33,
    0.138_431_62,
    0.141_263_29,
    0.144_128_47,
    0.147_027_27,
    0.149_959_79,
    0.152_926_15,
    0.155_926_46,
    0.158_960_84,
    0.162_029_38,
    0.165_132_2,
    0.168_269_4,
    0.171_441_1,
    0.174_647_4,
    0.177_888_42,
    0.181_164_24,
    0.184_474_99,
    0.187_820_77,
    0.191_201_68,
    0.194_617_83,
    0.198_069_32,
    0.201_556_25,
    0.205_078_74,
    0.208_636_87,
    0.212_230_76,
    0.215_860_5,
    0.219_526_2,
    0.223_227_96,
    0.226_965_87,
    0.230_740_05,
    0.234_550_58,
    0.238_397_57,
    0.242_281_12,
    0.246_201_33,
    0.250_158_28,
    0.254_152_1,
    0.258_182_85,
    0.262_250_66,
    0.266_355_6,
    0.270_497_8,
    0.274_677_3,
    0.278_894_26,
    0.283_148_74,
    0.287_440_84,
    0.291_770_65,
    0.296_138_27,
    0.300_543_79,
    0.304_987_3,
    0.309_468_92,
    0.313_988_71,
    0.318_546_78,
    0.323_143_2,
    0.327_778_1,
    0.332_451_54,
    0.337_163_62,
    0.341_914_42,
    0.346_704_06,
    0.351_532_6,
    0.356_400_14,
    0.361_306_8,
    0.366_252_6,
    0.371_237_68,
    0.376_262_12,
    0.381_326_01,
    0.386_429_43,
    0.391_572_48,
    0.396_755_23,
    0.401_977_78,
    0.407_240_2,
    0.412_542_6,
    0.417_885_07,
    0.423_267_67,
    0.428_690_5,
    0.434_153_64,
    0.439_657_17,
    0.445_201_2,
    0.450_785_8,
    0.456_411_02,
    0.462_077,
    0.467_783_8,
    0.473_531_5,
    0.479_320_18,
    0.485_149_94,
    0.491_020_85,
    0.496_933,
    0.502_886_5,
    0.508_881_32,
    0.514_917_7,
    0.520_995_57,
    0.527_115_1,
    0.533_276_4,
    0.539_479_5,
    0.545_724_46,
    0.552_011_4,
    0.558_340_4,
    0.564_711_5,
    0.571_124_83,
    0.577_580_44,
    0.584_078_42,
    0.590_618_84,
    0.597_201_79,
    0.603_827_34,
    0.610_495_57,
    0.617_206_6,
    0.623_960_4,
    0.630_757_14,
    0.637_596_87,
    0.644_479_7,
    0.651_405_64,
    0.658_374_82,
    0.665_387_3,
    0.672_443_16,
    0.679_542_5,
    0.686_685_3,
    0.693_871_76,
    0.701_101_9,
    0.708_375_78,
    0.715_693_5,
    0.723_055_1,
    0.730_460_74,
    0.737_910_4,
    0.745_404_2,
    0.752_942_2,
    0.760_524_5,
    0.768_151_15,
    0.775_822_2,
    0.783_537_8,
    0.791_297_9,
    0.799_102_7,
    0.806_952_26,
    0.814_846_6,
    0.822_785_75,
    0.830_769_9,
    0.838_799,
    0.846_873_2,
    0.854_992_6,
    0.863_157_2,
    0.871_367_1,
    0.879_622_4,
    0.887_923_1,
    0.896_269_3,
    0.904_661_2,
    0.913_098_65,
    0.921_581_86,
    0.930_110_9,
    0.938_685_7,
    0.947_306_5,
    0.955_973_3,
    0.964_686_3,
    0.973_445_3,
    0.982_250_6,
    0.991_102_1,
    1.000_000_00,
];

impl Color {
    pub const BLACK: Self = Self([0, 0, 0, 255]);
    pub const BLUE: Self = Self([0, 0, 255, 255]);
    pub const BROWN: Self = Self([165, 42, 42, 255]);
    pub const GREEN: Self = Self([0, 255, 0, 255]);
    pub const PURPLE: Self = Self([128, 0, 128, 255]);
    pub const RED: Self = Self([255, 0, 0, 255]);
    pub const WHITE: Self = Self([255, 255, 255, 255]);
    pub const YELLOW: Self = Self([255, 255, 0, 255]);

    pub const fn get_red(&self) -> u8 {
        self.0[0]
    }

    pub const fn get_green(&self) -> u8 {
        self.0[1]
    }

    pub const fn get_blue(&self) -> u8 {
        self.0[2]
    }

    pub const fn get_alpha(&self) -> u8 {
        self.0[3]
    }

    pub const fn new(red: u8, green: u8, blue: u8, alpha: u8) -> Self {
        Self([red, green, blue, alpha])
    }

    pub const fn rgb(red: u8, green: u8, blue: u8) -> Self {
        Self::new(red, green, blue, 255)
    }

    pub const fn from_u32_rgb(rgb: u32) -> Self {
        Self::new(
            ((rgb >> 16) & 0xFF) as u8,
            ((rgb >> 8) & 0xFF) as u8,
            (rgb & 0xFF) as u8,
            255,
        )
    }

    pub const fn as_u32(&self) -> u32 {
        let red = (self.0[0] as u32) << 16;
        let green = (self.0[1] as u32) << 8;
        let blue = self.0[2] as u32;

        red | green | blue
    }

    pub const fn new_f32(red: f32, green: f32, blue: f32, alpha: f32) -> Self {
        Self([
            (255.0 * red) as u8,
            (255.0 * green) as u8,
            (255.0 * blue) as u8,
            (255.0 * alpha) as u8,
        ])
    }

    #[must_use]
    pub const fn with_alpha(mut self, value: f32) -> Self {
        self.0[3] = (255.0 * value) as u8;

        self
    }

    pub const fn from_hsl(hue: f32, saturation: f32, lightness: f32) -> Self {
        let [red, green, blue] = if saturation == 0.0 {
            [lightness, lightness, lightness]
        } else {
            const fn hue_to_rgb(p: f32, q: f32, mut t: f32) -> f32 {
                if t < 0.0 {
                    t += 1.0;
                }

                if t > 1.0 {
                    t -= 1.0;
                }

                match t {
                    t if t < 1.0 / 6.0 => ((q - p) * 6.0) * t + p,
                    t if t < 1.0 / 2.0 => q,
                    t if t < 2.0 / 3.0 => ((q - p) * (2.0 / 3.0 - t)) * 6.0 + p,
                    _ => p,
                }
            }

            let q = if lightness < 0.5 {
                lightness * (1.0 + saturation)
            } else {
                lightness * -saturation + (lightness + saturation)
            };

            let p = 2.0f32 * lightness - q;

            [
                hue_to_rgb(p, q, (hue / 360.0) + 1.0 / 3.0),
                hue_to_rgb(p, q, hue / 360.0),
                hue_to_rgb(p, q, (hue / 360.0) - 1.0 / 3.0),
            ]
        };

        Self::new_f32(red, green, blue, 1.0)
    }

    pub const fn to_linear(&self) -> [f32; 3] {
        [
            color_to_linear(self.0[0]),
            color_to_linear(self.0[1]),
            color_to_linear(self.0[2]),
        ]
    }

    #[must_use]
    pub fn multiply_rgb(self, factor: f32) -> Self {
        let value: Vec3 = self.as_value();

        (value * factor).into()
    }
}
